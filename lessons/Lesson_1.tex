\documentclass[11pt,fleqn]{article}

%% This first part is the document header, which you don't need to edit.
%% Scroll down to \begin{document}

\usepackage[latin1]{inputenc}
\usepackage{enumerate}
\usepackage[hang,flushmargin]{footmisc}
\usepackage{mdframed}
\usepackage{color}
\usepackage{minted}

\setlength{\oddsidemargin}{0px}
\setlength{\textwidth}{460px}
\setlength{\voffset}{-1.5cm}
\setlength{\textheight}{20cm}
\setlength{\parindent}{0px}
\setlength{\parskip}{10pt}

\begin{document}
\begin{center}
{\Huge
Understanding the WPI Library
}
\end{center}

\begin{mdframed}

\end{mdframed}

\section{Introduction}

The WPI Library is a Java API that FIRST developed with the help of WPI (Worcester Polytechnic Institute)
to help students write readable code for the robot. Despite being very high level code, the WPI Library
allows users to have nearly full control over every aspect of the robot. The purpose of this document
is to introduce you to the big ideas from WPI Lib and explain important concepts required for programming
the robot. Rather than being a document detailing exactly what to type, this document outlines how the
WPI Lib actually works, what type of code goes where, and the coding styles/methodologies required by
the MidKnight Inventors. 

\section{Command Based Code}

There are various `ways' to write code for the robot. The standard for the MidKnight Inventors is to use
the \textbf{Command Based} coding style. The main reason that we choose to write our code in a command
based way is because it keeps the code modular, clean, and easy to debug. Also, command based code is
the most flexible and allows users to easily create additionally functionality that isn't already a part
of the WPI Lib. That being said, the command based style of writing code is the most conceptually complex
and requires a thorough understanding of what the code is doing at exactly every point. 

\section{The Master Classes}

When you first make a new command based robot program, there are three default classes present in the
\texttt{org.usfirst.teamXXXX.robot}. I refer to these three classes as the the \textbf{master classes}
since they directly control what the robot is doing. All the other code `plugs' into one of the three
master classes. 

\subsection{\texttt{Robot.java}}

\texttt{Robot.java} is both the simplest and most of the three master classes. \texttt{Robot.java} contains
instructions for what the robot should be doing during every state that it could be in. Since we are using
a command based system, all of our subsystems will be initialized in this class. You can think of the
entire robot being in a constant state machine controlled by the \textbf{Field Management System} (FMS).
\texttt{Robot.java} contains methods for all the different states that the robot could be in. 


Let's break down \texttt{Robot.java} to understand what it's doing at every point. Here's the code that
you would see in \texttt{Robot.java} if you made a new project: 

\begin{minted}{java}

package org.usfirst.frc.team1923.robot;
...

public class Robot extends IterativeRobot {

	public static final ExampleSubsystem exampleSubsystem = new ExampleSubsystem(); 
	public static OI oi;

    Command autonomousCommand;
    SendableChooser chooser;

    public void robotInit() {
		oi = new OI();
        chooser = new SendableChooser();
        chooser.addDefault("Default Auto", new ExampleCommand());
//        chooser.addObject("My Auto", new MyAutoCommand());
        SmartDashboard.putData("Auto mode", chooser);
    }
	
    public void disabledInit(){

    }
	
    public void disabledPeriodic() {
		Scheduler.getInstance().run();
    }


    public void autonomousInit() {
        autonomousCommand = (Command) chooser.getSelected();
        
		/* String autoSelected = SmartDashboard.getString("Auto Selector", "Default");
		switch(autoSelected) {
		case "My Auto":
			autonomousCommand = new MyAutoCommand();
			break;
		case "Default Auto":
		default:
			autonomousCommand = new ExampleCommand();
			break;
		} */
    	
    	// schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }

    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
    }

    public void teleopInit() {
		
    }


    public void teleopPeriodic() {
        Scheduler.getInstance().run();
    }
    
    public void testPeriodic() {
        LiveWindow.run();
    }
}
\end{minted}

Let's start by breaking down each method to see what it does. 

\subsubsection{\mint{java}|public void robotInit()|}
When the robot is first turned on and enabled, it will run this set of instructions. \texttt{robotInit
()} is where you should declare all of your defaults and initialize and logging. The most important thing
to remember is that \texttt{robotInit()} contains anything that you want the robot to do every time it's
placed on the field. Let's say you wanted an intake to always start in the down position, then you would
call that code here in \texttt{robotInit()}.

\subsubsection{\mint{java}|public void disabledInit()|}
Whenever the robot is disabled, this method is called. Although it's not used as often as \texttt{robotInit
()}, \texttt{disabledInit()} can have some important use cases. Occasionally, when the robot is disabled,
a command may be in the middle of running or there might be an over-arching command that runs asynchronously
that needs to be stopped. Stopping such a command would be done in \texttt{disabledInit()}. Additionally,
when the robot is disabled there are sometimes changes that we want to make to the robot without actually
pressing any buttons, this can be in the code fairly easily. Examples of such functionality would be making
sure an arm is retracted all the way so that the drive team can easily move the robot from the field to
the cart. 

\subsubsection{\mint{java}|public void disabledPeriodic()|}
As the method name suggests, this code will be called periodically while the robot is disabled. This means
that the code present in this method will run every few hundred milliseconds. While this method is rarely
used by teams because it presents a safety issue, it can be used for novelty actions. If there are rgb
leds on the robot, they can be controlled even while the robot is disabled by using this method. Once
again however, this \textbf{method should not be used} without the \textbf{explicit permission}
from the programming co-captain. 

\subsubsection{\mint{java}|public void autonomousInit()|}
\texttt{autonomousInit()} is called at the beginning of \textbf{autonomous mode} (commonly referred to
as auton). This function receives user input to determine which auton to run, and then runs said auton.
It is important to make sure that this part of the code has fall-backs because if an auton choose or the
desired input method doesn't work, then you will be left dead on the field for auton (which usually turns
out to be a bad thing). As such, we require that there are fail safes in place to ensure that \textit
{an auton} will run even if it isn't the best one.

\subsubsection{\mint{java}|public void autonoumousPeriodic()|}
Similar to \texttt{disabledPeriodic()}, this method runs every hundred or so milliseconds during auton.
Unlike \texttt{disabledPeriodic()}, this method can be used in any way that you please since it doesn't
pose a safety problem.

\subsubsection{\mint{java}|public void teleopInit()|}
Whenever tele-operated (teleOp) mode is enabled, the FMS will call this method. You would use this method
to default to a position after auton and use \texttt{robotInit()} to default to a position before auton.
If there are senors that need to be zeroed or solenoids that need to be activated before the start of
teleOp but after auton, then this is where that code would. 

\subsubsection{\mint{java}|public void teleopPeriodic()|}


\end{document}
